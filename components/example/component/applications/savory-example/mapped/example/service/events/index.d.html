<%& '/site/header/' %>
<% exampleHeader('Events', 'Service'); %>

<%

document.executeOnce('/savory/service/events/')
document.executeOnce('/prudence/logging/')

Savory.Events.subscribe({
	name: 'payments.successful',
	id: 'example',
	dependencies: '/prudence/logging/',
	fn: function(name, context) {
		Prudence.Logging.getLogger().info('User {0} has paid us {1}!', context.username, context.amount)
	}
})

if (conversation.request.method.name == 'POST') {
	var async = conversation.form.get('async') == 'async' ? true : false
	var distributed = conversation.form.get('distributed') == 'distributed' ? true : false
	Prudence.Logging.getLogger().info('Firing event: async={0}, distributed={1}', async, distributed)
	Savory.Events.fire({
		name: 'payments.successful',
		async: async,
		distributed: distributed,
		context: {
			username: 'Isaac Newton',
			amount: '$123.45'
		}
	})
	print('<p class="note">The event was fired, with <b>async={0}</b> and <b>distributed={1}</b>! Check the logs to see it in action.</p>'.cast(async, distributed))
}

%>

<p>
	Though we're subscribing to the event every time you reload this page, we don't have to, because we've configured
	the Events Service to use a persistent storage for listeners. Check out the "events" collection in MongoDB to
	see its persistent storage.
</p>
<p>
	If you're only running a single node, the distributed example won't be too exciting, because it will always be
	executed locally (although it does use the distribution mechanism). Try running a cluster of nodes to get
	a sense of its real power: the listener will be called on a different node every time it's fired.
</p>

<form method="post">
	<p>
		<input type="checkbox" name="async" value="async" /> Asynchronous
	</p>
	<p>
		<input type="checkbox" name="distributed" value="distributed" /> Distributed (implies asynchronous, too)
	</p>
	<p>
		<input type="submit" value="Fire the event" />
	</p>
</form>

<% exampleFooter('Events', 'Service'); %>
<%& '/site/footer/' %>